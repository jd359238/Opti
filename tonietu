#
# Rozne implementacje pivot rules
#
import random
import operator
import numpy
import math
import copy

# Porzadek leksykograficzny, minimum

def lexicographical_min_entering(self):
	return min(self.possible_entering())

def lexicographical_min_leaving(self):
	return min(self.possible_leaving())

# Porzadek leksykograficzny, maximum

def lexicographical_max_entering(self):
	return max(self.possible_entering())

def lexicographical_max_leaving(self):
	return max(self.possible_leaving())

# Największy wzrost

def largest_increase(self):
    obj_now = self.objective_value()
    obj_max = obj_now
    enter_max = ""
    leave_max = ""
    temp = copy.deepcopy(self)
    x = self.possible_entering()[0]
    temp.enter(x)
    y = temp.possible_leaving()[0]
    obj_curr = temp.objective_value()
    obj_max = obj_curr
    enter_max = x
    leave_max = y
    for i in self.possible_entering():
        temp = copy.deepcopy(self)
        temp.enter(i)
        for j in temp.possible_leaving():
            temp.leave(j)
            temp.update()
            obj_curr = temp.objective_value()
            if math.fabs(obj_curr-obj_now) >= math.fabs(obj_max-obj_now):
                obj_max = obj_curr
                enter_max = i
                leave_max = j
            temp = copy.deepcopy(self)
            temp.enter(i)
    return [enter_max, leave_max]

# Najmniejszy wzrost

def smallest_increase(self):
    obj_now = self.objective_value()
    obj_min = obj_now
    enter_min = ""
    leave_min = ""
    temp = copy.deepcopy(self)
    x = self.possible_entering()[0]
    temp.enter(x)
    y = temp.possible_leaving()[0]
    obj_curr = temp.objective_value()
    obj_min = obj_curr
    enter_min = x
    leave_min = y
    for i in self.possible_entering():
        temp = copy.deepcopy(self)
        temp.enter(i)
        for j in temp.possible_leaving():
            temp.leave(j)
            temp.update()
            obj_curr = temp.objective_value()
            if math.fabs(obj_curr-obj_now) <= math.fabs(obj_min-obj_now):
                obj_min = obj_curr
                enter_min = i
                leave_min = j
            temp = copy.deepcopy(self)
            temp.enter(i)
    return [enter_min, leave_min]
    

# Największy wspolczynnik

def max_coefficient_entering(self):
    max_value = max(self.objective_coefficients())
    max_index = list(self.objective_coefficients()).index(max_value)
    return list(self.nonbasic_variables())[max_index] 

# Losowy wybor wierzcholka

def uni_random_entering(self):
    return random.choice(self.possible_entering())

def uni_random_leaving(self):
    return random.choice(self.possible_leaving())

# Średnia ważona

def weighted_random_entering(self):
    A = self.possible_entering()
    licz = 1
    B = []
    for j in A[int(len(A)/2)::-1]:
        for i in range(0, licz):
            B += [A.index(j)]
        licz = 2 * licz
    licz=2
    for j in A[int(len(A)/2+1):]:
        for i in range(0, licz):
            B += [A.index(j)]
        licz = 2 * licz
    draw = random.choice(B)
    return A[draw]

def weighted_random_leaving(self):
    A = self.possible_leaving()
    licz = 1
    B = []
    for j in A[int(len(A)/2)::-1]:
        for i in range(0, licz):
            B += [A.index(j)]
        licz = 2 * licz
    licz=2
    for j in A[int(len(A)/2+1):]:
        for i in range(0, licz):
            B += [A.index(j)]
        licz = 2 * licz
    draw = random.choice(B)
    return A[draw]

# No - stromo
def steepest_edge(self):
    v_old = [0 for i in range(0,len(self.basic_variables()) + len(self.nonbasic_variables()))]
    c = [0 for i in range(0,len(self.basic_variables()) + len(self.nonbasic_variables()))]
    c_old = self.objective_coefficients()
    basic = self.basic_variables()
    non_basic = self.nonbasic_variables()
    max_entering = ""
    max_leaving = ""
    k = 0
    for i in basic:
        v_old[int(str(list(i)[0][1])[1:]) - 1] = (self.constant_terms())[k] #to dziala
        k += 1
    licz=0
    for i in non_basic:
        c[int(str(list(i)[0][1])[1:]) - 1] = c_old[licz]
        licz += 1
    c = vector(c)
    temp = self
    x = self.possible_entering()[0]
    temp.enter(x)
    y = temp.possible_leaving()[0]
    v_new = list(v_old)
    v_new[int(str(x)[1:]) - 1] = (temp.constant_terms())[list(temp.basic_variables()).index(y)]
    v_new[int(str(y)[1:]) - 1] = 0
    v = vector(v_new) - vector(v_old)
    calc = numpy.dot(c, v)
    if numpy.linalg.norm(v) == 0:
        return [x, y]
    else:
        max = calc/numpy.linalg.norm(v)
    max_entering = x
    max_leaving = y
    for x in self.possible_entering():
        temp = self
        temp.enter(x)
        for y in temp.possible_leaving():
            v_new = list(v_old)
            v_new[int(str(x)[1:]) - 1] = (temp.constant_terms())[list(temp.basic_variables()).index(y)]
            v_new[int(str(y)[1:]) - 1] = 0
            v = vector(v_new) - vector(v_old)
            calc = numpy.dot(c, v)
            if numpy.linalg.norm(v) == 0:
                return [x, y]
            else:
                calc = calc/numpy.linalg.norm(v)
            temp = self
            if calc >= max:
                max = calc
                max_entering = x
                max_leaving = y
    self.enter(max_entering)
    return [max_entering, max_leaving]

# Pierwszy po lewej

def farthest_left_entering(self):
    return self.possible_entering()[0]

def farthest_left_leaving(self):
    return self.possible_leaving()[0]

# Pierwszy po prawej

def farthest_right_entering(self):
    return self.possible_entering()[len(self.possible_entering()) - 1]

def farthest_right_leaving(self):
    return self.possible_leaving()[len(self.possible_leaving()) - 1]

#
# Wybor funkcji pivot
#

def my_entering(self):
    #return lexicographical_min_entering(self)
    #return lexicographical_max_entering(self)
    return largest_increase(self)[0]
    #return smallest_increase(self)[0]
    #return max_coefficient_entering(self)
    #return uni_random_entering(self)
    #return weighted_random_entering(self)
    #return steepest_edge(self)[0]
    #return farthest_left_entering(self)
    #return farthest_right_entering(self)

def my_leaving(self):
    #return lexicographical_min_leaving(self)
    #return lexicographical_max_leaving(self)
    return largest_increase(self)[1]
    #return smallest_increase(self)[1]
    #return lexicographical_min_leaving(self)
    #return uni_random_leaving(self)
    #return weighted_random_leaving(self)
    #return steepest_edge(self)[1]
    #return farthest_left_leaving(self)
    #return farthest_right_leaving(self)

#
# Definicja problemu
#

LP = \
"""
Maximize
+ 8317 x1 + 3972 x2 + 106 x3 + 7625 x4 - 7585 x5 + 9802 x6 + 7386 x7 - 1932 x8 + 7117 x9 + 619 x10 + 1758 x11 + 5553 x12 + 8346 x13 + 135 x14 - 5205 x15 - 3659 x16 + 5614 x17 - 8377 x18 - 5504 x19 + 8127 x20 - 2161 x21 + 1046 x22 + 3462 x23 + 1757 x24 + 2648 x25 - 9893 x26 - 5850 x27 - 4709 x28 + 8575 x29 + 9214 x30 + 3842 x31 - 9737 x32 + 9894 x33 + 6789 x34 - 1913 x35 - 4700 x36 - 5007 x37 + 651 x38 + 2569 x39 + 6870 x40 + 8261 x41 + 8460 x42 + 7598 x43 - 2961 x44 + 3812 x45 - 151 x46 - 7020 x47 + 5356 x48 + 5073 x49 - 3226 x50 
Subject To
+ 6990 x2 - 5483 x5 + 6109 x11 - 5301 x12 + 1260 x13 + 1815 x14 - 117 x16 + 9831 x17 - 6249 x20 + 6001 x23 + 5252 x24 + 3994 x26 + 5605 x28 + 4705 x30 + 4034 x33 + 7350 x34 - 7063 x35 - 5611 x38 + 6815 x40 + 7231 x44 - 7151 x46 + 7852 x49 + 3936 x50  <= 5077
- 2988 x8 + 9759 x12 + 4734 x16 + 463 x17 + 9855 x21 + 501 x22 + 5709 x23 + 8414 x27 - 5161 x29 - 5603 x32 + 3463 x37 + 3021 x38 - 8346 x39 + 4887 x42 - 6477 x47 - 76 x48  <= 9587
- 8861 x7 + 4849 x12 + 9219 x14 + 6755 x26 - 6655 x27 + 8629 x34 + 109 x36 - 3140 x44 + 9926 x45 - 6335 x46 + 264 x48 + 379 x49 + 2875 x50  <= 831
+ 5324 x8 - 7559 x12 - 9601 x13 + 230 x16 + 5933 x17 + 2948 x18 + 8598 x20 + 5028 x24 + 2858 x27 + 3830 x28 + 7368 x31 + 991 x32 + 8788 x33 - 6512 x34 + 7848 x36 + 6292 x41 + 6908 x45 + 6815 x47  <= 7826
+ 1966 x1 + 1292 x2 + 6133 x3 + 4632 x9 + 2402 x13 + 3890 x14 + 8246 x15 + 3432 x16 + 2064 x18 + 6021 x20 + 2437 x23 + 5474 x24 - 755 x28 + 4647 x30 + 2274 x33 + 6010 x35 + 821 x37 - 1587 x38 + 3104 x42 + 9699 x50  <= 2437
+ 1674 x1 - 9905 x4 - 3355 x6 + 7869 x8 + 898 x9 + 5596 x10 + 6356 x17 + 652 x23 - 9385 x26 + 2942 x27 + 7305 x28 + 615 x30 + 4999 x31 - 3300 x32 + 5558 x35 - 1964 x50  <= 4000
+ 3707 x1 + 4083 x5 + 9936 x8 + 9070 x10 + 7098 x11 + 5708 x12 + 4156 x14 - 7241 x19 + 5891 x20 + 3867 x23 - 580 x26 + 4766 x29 - 158 x30 + 4887 x35 - 8219 x36 + 9262 x38 + 1244 x41 + 3979 x43 + 7130 x45 + 449 x46 + 7613 x47 - 3630 x48 + 6503 x50  <= 5588
- 3870 x1 + 3446 x2 - 2442 x5 - 9406 x7 - 6207 x9 - 5007 x15 + 7621 x16 + 4355 x18 + 7966 x24 - 9572 x25 + 7281 x27 - 1158 x29 + 4429 x30 + 7838 x34 + 92 x36 + 9980 x37 + 9210 x49  <= 2043
- 5362 x1 - 2481 x3 + 6388 x5 + 2247 x12 + 2854 x13 - 3021 x14 + 5129 x17 + 2400 x19 + 7511 x21 - 8272 x22 - 4551 x24 - 5176 x29 - 3418 x34 + 2532 x35 + 1014 x47  <= 8856
- 6652 x4 - 4562 x5 + 3432 x7 - 3092 x9 - 7135 x10 + 3084 x11 + 5890 x12 - 679 x18 + 3648 x22 + 7596 x23 + 1529 x25 + 236 x38 + 6612 x40 + 7229 x43 - 2533 x46  <= 6109
- 4486 x1 + 9535 x2 + 4968 x6 + 2213 x9 + 8093 x13 + 540 x18 - 1783 x21 + 4635 x27 + 2514 x29 - 4015 x34 - 7218 x38 - 3413 x40 - 3307 x41 + 376 x42 - 5636 x45 + 6870 x46 + 5644 x47  <= 4164
+ 9627 x2 + 806 x5 - 4562 x7 + 165 x17 - 9011 x21 + 6432 x22 - 8770 x33 + 326 x34 - 5273 x41 + 5638 x42 + 62 x43 + 4687 x47 + 8449 x50  <= 7365
+ 1495 x4 + 4820 x8 + 3734 x10 - 9186 x11 + 5036 x12 + 558 x13 + 344 x14 + 5918 x18 + 2308 x20 + 7081 x22 + 8408 x25 - 7925 x26 + 8847 x27 + 2581 x28 + 2323 x31 + 4401 x32 + 68 x34 + 615 x38 - 5021 x39 + 1796 x40 - 3059 x42 - 9546 x43 + 2773 x47 + 553 x48 + 6774 x49  <= 2006
+ 9224 x4 - 2216 x8 + 36 x9 + 262 x15 - 7484 x22 + 5164 x25 + 2570 x28 - 735 x31 - 9073 x35 + 1972 x44 + 8642 x45 + 7617 x46 + 7696 x48  <= 2298
- 1076 x2 + 7483 x8 - 1450 x13 + 8621 x15 - 7963 x16 - 6084 x28 + 2797 x29 + 8056 x30 + 849 x33 + 5836 x36 - 5370 x38 + 3323 x40 + 1320 x43 - 3276 x44 + 6209 x45 + 5065 x47 + 5951 x49  <= 9836
- 9941 x2 + 869 x4 + 2218 x6 - 6025 x12 - 4946 x14 + 3609 x15 - 6903 x25 + 3673 x27 + 3835 x30 + 9756 x35 - 5178 x38 + 6793 x39 - 3465 x40 + 508 x45 - 1061 x46 + 5399 x48 + 9617 x50  <= 4100
+ 3223 x2 + 1450 x7 + 4701 x12 + 9751 x17 + 929 x20 + 8903 x25 - 6680 x26 + 4967 x28 + 8827 x31 + 6084 x36 + 2183 x47 - 4467 x50  <= 2177
+ 4566 x1 + 5390 x2 - 6558 x4 - 9315 x9 + 8581 x10 + 7021 x17 + 9795 x20 - 5160 x21 + 4554 x22 + 5141 x25 + 3898 x28 + 2102 x29 - 3724 x34 + 4090 x36 + 4167 x37 + 2348 x41 + 8939 x43 - 7669 x44 + 2044 x45 + 6549 x49 - 6246 x50  <= 3274
+ 2842 x1 - 6801 x3 + 7372 x5 + 8159 x10 + 5234 x18 - 8491 x20 - 1516 x21 + 4321 x24 + 2456 x26 + 9377 x28 - 7565 x30 + 2976 x32 + 3703 x39 - 3053 x42 + 7916 x44 - 2665 x45 + 4191 x49 + 2334 x50  <= 868
+ 539 x4 - 9477 x5 + 7529 x6 - 1338 x7 + 8405 x10 - 7414 x11 + 9052 x12 - 1958 x14 - 267 x15 + 9060 x16 - 4138 x19 + 1922 x21 + 2467 x22 + 1444 x23 + 4752 x24 + 3055 x25 + 501 x26 + 6979 x28 + 5297 x29 + 3944 x32 + 3522 x36 + 4002 x37 + 9337 x41 - 4993 x44 + 8826 x45 + 5859 x47  <= 7168
+ 7962 x1 - 597 x4 - 4505 x6 + 7665 x7 + 796 x22 + 9518 x29 + 1218 x31 - 866 x35 + 8513 x37 + 4510 x43 + 7653 x45 + 6976 x46 - 2399 x49  <= 9997
+ 6791 x1 + 7317 x2 - 5594 x3 - 7319 x5 - 1892 x7 - 4915 x8 + 6089 x9 + 8986 x12 + 4639 x13 + 6073 x14 + 2210 x15 - 2519 x16 + 4143 x20 + 1054 x23 - 6307 x24 - 3666 x27 + 7122 x31 - 3221 x33 + 3292 x36 + 4225 x37 - 6307 x39 + 1400 x44 + 368 x46 + 2201 x48  <= 7861
+ 6809 x1 - 8419 x2 + 3199 x4 + 1085 x5 + 3393 x7 + 3861 x9 - 9051 x10 + 5146 x14 + 55 x15 + 6389 x17 + 9823 x18 - 7976 x22 + 9163 x24 + 2390 x27 + 2983 x33 - 5279 x39 + 5132 x40 + 6901 x41 + 239 x42 - 9340 x44 - 2569 x45 - 4331 x47 - 3483 x50  <= 3343
+ 8569 x2 - 2460 x3 - 2068 x6 - 5530 x9 + 2516 x19 + 8334 x25 - 8302 x28 + 5500 x30 - 8367 x32 + 6023 x35 - 8988 x37 + 8684 x38 + 3527 x39 + 3005 x40 + 2169 x42 + 7463 x47 - 9107 x48  <= 5124
+ 6365 x5 + 482 x6 + 5899 x10 + 3161 x11 - 9684 x12 + 1091 x17 + 3236 x18 + 2897 x19 + 7328 x20 + 4227 x23 + 3489 x24 + 1040 x25 + 7092 x26 - 5587 x27 + 649 x29 - 8638 x30 + 4969 x31 + 9765 x35 - 671 x40 - 2073 x47 + 4730 x48  <= 1614
- 561 x5 + 1591 x6 + 4988 x7 + 3977 x12 + 6734 x13 - 4771 x19 + 4589 x21 + 3690 x24 + 4119 x26 + 3956 x31 + 7781 x35 - 2903 x37 - 5151 x40 - 4461 x43 + 9579 x44 + 7626 x47 + 5674 x50  <= 2000
+ 8843 x1 + 7498 x3 + 6202 x5 - 796 x6 + 3865 x7 + 3210 x12 + 8025 x19 + 395 x23 + 1039 x26 + 6037 x27 - 3888 x32 + 6237 x33 + 4918 x34 - 7278 x36 - 749 x38 + 2653 x40 + 1570 x42 + 132 x45 - 9452 x46 - 8174 x47 - 4514 x49 + 100 x50  <= 866
- 3084 x2 + 5910 x6 + 1426 x8 + 6111 x10 - 8571 x11 + 3804 x12 + 9766 x13 - 8726 x16 + 2537 x19 + 8812 x21 + 8235 x23 - 7555 x29 - 9494 x33 + 774 x34 + 4931 x35 + 8473 x36 + 7327 x39 + 9902 x40 + 405 x42 - 7186 x46 - 994 x47 + 6481 x49 - 8661 x50  <= 950
+ 6296 x6 - 8062 x7 + 7006 x8 + 5405 x10 - 3934 x12 - 357 x14 + 7112 x15 + 1611 x16 - 6361 x20 + 265 x21 + 5203 x24 + 5953 x25 + 2152 x26 + 8980 x27 + 5135 x28 - 8371 x29 - 4071 x30 + 161 x31 - 9249 x32 + 3196 x35 - 3374 x39 + 3322 x42 + 1255 x47 + 7335 x49  <= 5514
+ 8987 x2 + 5996 x4 - 8151 x5 + 1751 x7 + 8190 x8 - 6605 x11 + 7410 x15 + 8743 x16 + 2309 x22 + 5723 x24 + 5485 x27 + 3182 x29 - 1172 x32 + 7257 x40 + 9776 x42 + 4633 x45 - 188 x50  <= 6009
x1 >= 0
x1 <= 1
x2 >= 0
x2 <= 1
x3 >= 0
x3 <= 1
x4 >= 0
x4 <= 1
x5 >= 0
x5 <= 1
x6 >= 0
x6 <= 1
x7 >= 0
x7 <= 1
x8 >= 0
x8 <= 1
x9 >= 0
x9 <= 1
x10 >= 0
x10 <= 1
x11 >= 0
x11 <= 1
x12 >= 0
x12 <= 1
x13 >= 0
x13 <= 1
x14 >= 0
x14 <= 1
x15 >= 0
x15 <= 1
x16 >= 0
x16 <= 1
x17 >= 0
x17 <= 1
x18 >= 0
x18 <= 1
x19 >= 0
x19 <= 1
x20 >= 0
x20 <= 1
x21 >= 0
x21 <= 1
x22 >= 0
x22 <= 1
x23 >= 0
x23 <= 1
x24 >= 0
x24 <= 1
x25 >= 0
x25 <= 1
x26 >= 0
x26 <= 1
x27 >= 0
x27 <= 1
x28 >= 0
x28 <= 1
x29 >= 0
x29 <= 1
x30 >= 0
x30 <= 1
x31 >= 0
x31 <= 1
x32 >= 0
x32 <= 1
x33 >= 0
x33 <= 1
x34 >= 0
x34 <= 1
x35 >= 0
x35 <= 1
x36 >= 0
x36 <= 1
x37 >= 0
x37 <= 1
x38 >= 0
x38 <= 1
x39 >= 0
x39 <= 1
x40 >= 0
x40 <= 1
x41 >= 0
x41 <= 1
x42 >= 0
x42 <= 1
x43 >= 0
x43 <= 1
x44 >= 0
x44 <= 1
x45 >= 0
x45 <= 1
x46 >= 0
x46 <= 1
x47 >= 0
x47 <= 1
x48 >= 0
x48 <= 1
x49 >= 0
x49 <= 1
x50 >= 0
x50 <= 1
Bounds
Generals
x1
x2
x3
x4
x5
x6
x7
x8
x9
x10
x11
x12
x13
x14
x15
x16
x17
x18
x19
x20
x21
x22
x23
x24
x25
x26
x27
x28
x29
x30
x31
x32
x33
x34
x35
x36
x37
x38
x39
x40
x41
x42
x43
x44
x45
x46
x47
x48
x49
x50
End
"""

#with open('problem.lp', 'r') as lpfile:
#    LP=lpfile.read()

##############################################################################
##############################################################################
##############################################################################
##############################################################################
##############################################################################
##############################################################################
##############################################################################
##############################################################################

from sage.misc.html import HtmlFragment
import types

def my_run_simplex_method(self):
    output = []
    while not self.is_optimal():
        self.pivots += 1
        if self.entering() is None:
            self.enter(self.pivot_select_entering())
        if self.leaving() is None:
            if self.possible_leaving():
                self.leave(self.pivot_select_leaving())

        output.append(self._html_())
        if self.leaving() is None:
            output.append("The problem is unbounded in $()$ direction.".format(latex(self.entering())))
            break
        output.append(self._preupdate_output("primal"))
        self.update()
    if self.is_optimal():
        output.append(self._html_())
    return HtmlFragment("\n".join(output))

#
# Parsowanie danych
#

class Matrix:
    """ output matrix class """
    
    class Objective:
        def __init__(self, expression, sense, name):
            if name:
                self.name = name[int(0)]
            else:
                self.name = ""
            self.sense = sense # 1 is minimise, -1 is maximise
            self.expression = expression # a dict with variable names as keys, and coefficients as values

    class Constraint:
        def __init__(self, expression, sense, rhs, name):
            if name:
                self.name = name[int(0)]
            else:
                self.name = ""
            self.sense = sense # 1 is geq, 0 is eq, -1 is leq
            self.rhs = rhs
            self.expression = expression
    
    class Variable:
        def __init__(self, bounds, category, name):
            self.name = name
            self.bounds = (bounds["lb"], bounds["ub"]) # a tuple (lb, ub)
            self.category = category # 1 for int, 0 for linear

    def __init__(self, parserObjective, parserConstraints, parserBounds, parserGenerals, parserBinaries):

        self.objective = Matrix.Objective(varExprToDict(parserObjective.varExpr), objSenses[parserObjective.objSense], parserObjective.name)
        
        self.constraints = [Matrix.Constraint(varExprToDict(c.varExpr), constraintSenses[c.sense], c.rhs, c.name) for c in parserConstraints]
        
        boundDict = getBoundDict(parserBounds, parserBinaries) # can't get parser to generate this dict because one var can have several bound statements
        
        allVarNames = set()
        allVarNames.update(self.objective.expression.keys())
        for c in self.constraints:
            allVarNames.update(c.expression.keys())
        allVarNames.update(parserGenerals)
        allVarNames.update(boundDict.keys())
        
        self.variables = [Matrix.Variable(boundDict[vName], ((vName in list(parserGenerals)) or (vName in list(parserBinaries))), vName) for vName in allVarNames]

    def __repr__(self):
        return "Objective%s\n\nConstraints (%d)%s\n\nVariables (%d)%s" \
        %("\n%s %s %s"%(self.objective.sense, self.objective.name, str(self.objective.expression)), \
          len(self.constraints), \
          "".join(["\n(%s, %s, %s, %s)"%(c.name, str(c.expression), c.sense, c.rhs) for c in self.constraints]), \
          len(self.variables), \
          "".join(["\n(%s, %s, %s)"%(v.name, str(v.bounds), v.category) for v in self.variables]))

    def getInteractiveLPProblem(self):
        A = [[0 for x in range(len(self.variables))] for y in range(len(self.constraints))]
        b = [0] * len(self.constraints)
        c = [0] * len(self.variables)

        for i, constraint in enumerate(self.constraints):
            for v, a in constraint.expression.iteritems():
                if constraint.sense == 1:
                    A[i][map(lambda x: x.name, self.variables).index(v)] = -a
                else:
                    A[i][map(lambda x: x.name, self.variables).index(v)] = a

                if constraint.sense == 1:		
                    b[i] = -constraint.rhs
                else:
                    b[i] = constraint.rhs 

        for v, a in self.objective.expression.iteritems():
            if self.objective.sense == 1:
                c[map(lambda x: x.name, self.variables).index(v)] = -a
            else:
                c[map(lambda x: x.name, self.variables).index(v)] = a

        AA = ()
        bb = ()
        cc = ()

        for a in A:
            aaa=[]
            for aa in a:
                aaa.append(aa*int(10000))        
            AA = AA + (list(aaa),)
        for b in b:
            bb = bb + (b*int(10000),)
        for c in c:
            cc = cc + (c*int(10000),)

        lpp = InteractiveLPProblemStandardForm(AA,bb,cc)

        for i, v in enumerate(self.variables):
            if v.bounds[int(1)] < infinity:
                coef = [0,] * len(self.variables)
                coef[i] = 1
                lpp = lpp.add_constraint((coef), v.bounds[int(1)]*int(10000))
            if v.bounds[int(0)] > -infinity:
                coef = [0,] * len(self.variables)
                coef[i] = -1
                lpp = lpp.add_constraint((coef), -v.bounds[int(0)]*int(10000))

        return lpp

def varExprToDict(varExpr):
    return dict((v.name[int(0)], v.coef) for v in varExpr)

def getBoundDict(parserBounds, parserBinaries):
    boundDict = defaultdict(lambda: {"lb": -infinity, "ub": infinity}) # need this versatility because the lb and ub can come in separate bound statements

    for b in parserBounds:
        bName = b.name[int(0)]
        
        # if b.free, default is fine

        if b.leftbound:
            if constraintSenses[b.leftbound.sense] >= 0: # NUM >= var
                boundDict[bName]["ub"] = b.leftbound.numberOrInf

            if constraintSenses[b.leftbound.sense] <= 0: # NUM <= var
                boundDict[bName]["lb"] = b.leftbound.numberOrInf
        
        if b.rightbound:
            if constraintSenses[b.rightbound.sense] >= 0: # var >= NUM
                boundDict[bName]["lb"] = b.rightbound.numberOrInf

            if constraintSenses[b.rightbound.sense] <= 0: # var <= NUM
                boundDict[bName]["ub"] = b.rightbound.numberOrInf
    
    for bName in parserBinaries:
        boundDict[bName]["lb"] = 0
        boundDict[bName]["ub"] = 1

    return boundDict
    

def multiRemove(baseString, removables):
    """ replaces an iterable of strings in removables 
        if removables is a string, each character is removed """
    for r in removables:
        try:
            baseString = baseString.replace(r, "")
        except TypeError:
            raise TypeError, "Removables contains a non-string element"
    return baseString

from pyparsing import *
from sys import argv, exit
from collections import defaultdict

MINIMIZE = 1
MAXIMIZE = -1

objSenses = {"max": MAXIMIZE, "maximum": MAXIMIZE, "maximize": MAXIMIZE, \
             "min": MINIMIZE, "minimum": MINIMIZE, "minimize": MINIMIZE}

GEQ = 1
EQ = 0
LEQ = -1

constraintSenses = {"<": LEQ, "<=": LEQ, "=<": LEQ, \
                    "=": EQ, \
                    ">": GEQ, ">=": GEQ, "=>": GEQ}

infinity = 1E30

def read(fullDataString):
    #name char ranges for objective, constraint or variable
    allNameChars = alphanums + "!\"#$%&()/,.;?@_'`{}|~"
    firstChar = multiRemove(allNameChars, nums + "eE.") #<- can probably use CharsNotIn instead
    name = Word(firstChar, allNameChars, max=255)
    keywords = ["inf", "infinity", "max", "maximum", "maximize", "min", "minimum", "minimize", "s.t.", "st", "bound", "bounds", "bin", "binaries", "binary", "gen",  "general", "end"]
    pyKeyword = MatchFirst(map(CaselessKeyword, keywords))
    validName = ~pyKeyword + name
    validName = validName.setResultsName("name")

    colon = Suppress(oneOf(": ::"))
    plusMinus = oneOf("+ -")
    inf = oneOf("inf infinity", caseless=True)
    number = Word(nums+".")
    sense = oneOf("< <= =< = > >= =>").setResultsName("sense")

    # section tags
    objTagMax = oneOf("max maximum maximize", caseless=True)
    objTagMin = oneOf("min minimum minimize", caseless=True)
    objTag = (objTagMax | objTagMin).setResultsName("objSense")

    constraintsTag = oneOf(["subj to", "subject to", "s.t.", "st"], caseless=True)

    boundsTag = oneOf("bound bounds", caseless=True)
    binTag = oneOf("bin binaries binary", caseless=True)
    genTag = oneOf("gen general", caseless=True)

    endTag = CaselessLiteral("end")

    # coefficient on a variable (includes sign)
    firstVarCoef = Optional(plusMinus, "+") + Optional(number, "1")
    firstVarCoef.setParseAction(lambda tokens: eval("".join(tokens))) #TODO: can't this just be eval(tokens[0] + tokens[1])?

    coef = plusMinus + Optional(number, "1")
    coef.setParseAction(lambda tokens: eval("".join(tokens))) #TODO: can't this just be eval(tokens[0] + tokens[1])?

    # variable (coefficient and name)
    firstVar = Group(firstVarCoef.setResultsName("coef") + validName)
    var = Group(coef.setResultsName("coef") + validName)

    # expression
    varExpr = firstVar + ZeroOrMore(var)
    varExpr = varExpr.setResultsName("varExpr")

    # objective
    objective = objTag + Optional(validName + colon) + varExpr
    objective = objective.setResultsName("objective")

    # constraint rhs
    rhs = Optional(plusMinus, "+") + number
    rhs = rhs.setResultsName("rhs")
    rhs.setParseAction(lambda tokens: eval("".join(tokens)))

    # constraints
    constraint = Group(Optional(validName + colon) + varExpr + sense + rhs)
    constraints = ZeroOrMore(constraint)
    constraints = constraints.setResultsName("constraints")

    # bounds
    signedInf = (plusMinus + inf).setParseAction(lambda tokens:(tokens[int(0)] == "+") * infinity)
    signedNumber = (Optional(plusMinus, "+") + number).setParseAction(lambda tokens: eval("".join(tokens)))  # this is different to previous, because "number" is mandatory not optional
    numberOrInf = (signedNumber | signedInf).setResultsName("numberOrInf")
    ineq = numberOrInf & sense
    sensestmt = Group(Optional(ineq).setResultsName("leftbound") + validName + Optional(ineq).setResultsName("rightbound"))
    freeVar = Group(validName + Literal("free"))

    boundstmt = freeVar | sensestmt 
    bounds = boundsTag + ZeroOrMore(boundstmt).setResultsName("bounds")

    # generals
    generals = genTag + ZeroOrMore(validName).setResultsName("generals") 

    # binaries
    binaries = binTag + ZeroOrMore(validName).setResultsName("binaries")

    varInfo = ZeroOrMore(bounds | generals | binaries)

    grammar = objective + constraintsTag + constraints + varInfo + endTag

    # commenting
    commentStyle = Literal("\\") + restOfLine
    grammar.ignore(commentStyle)

    # parse input string
    parseOutput = grammar.parseString(fullDataString)

    # create generic output Matrix object
    m = Matrix(parseOutput.objective, parseOutput.constraints, parseOutput.bounds, parseOutput.generals, parseOutput.binaries)

    return m

#
# Parsowanie danych
#

m = read(LP)
P = m.getInteractiveLPProblem()

#
# Ustawienie wlasnej funkcji pivot
#

D = P.initial_dictionary()

if not D.is_feasible():
    print "The initial dictionary is infeasible, solving auxiliary problem."
    # Phase I
    AD = P.auxiliary_problem().initial_dictionary()
    AD.enter(P.auxiliary_variable())
    AD.leave(min(zip(AD.constant_terms(), AD.basic_variables()))[int(1)])
    AD.run_simplex_method()
    if AD.objective_value() < 0:
        print "The original problem is infeasible."
        P._final_dictionary = AD
    else:
        print "Back to the original problem."
        D = P.feasible_dictionary(AD)


D.run_simplex_method = types.MethodType(my_run_simplex_method, D)
D.pivots = 0

D.pivot_select_entering = types.MethodType(my_entering, D)
D.pivot_select_leaving = types.MethodType(my_leaving, D)

#
# Algorytm sympleks
#

if D.is_feasible():
    D.run_simplex_method()

print "Number of pivot steps: ", D.pivots

print D.objective_value()
print P.optimal_solution()
